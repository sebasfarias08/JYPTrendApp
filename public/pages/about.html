<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <title>About</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="h-screen overflow-hidden flex flex-col bg-slate-950 text-slate-100">
  <header id="appShellTop"></header>

  <main class="flex-1 overflow-y-auto p-4 pb-24 space-y-4">
    <section class="rounded-2xl border border-slate-800 bg-slate-900 p-4 space-y-2">
      <h2 class="text-sm font-semibold text-slate-200">Version de la aplicacion</h2>
      <div class="text-sm text-slate-300">Version local (SW activo): <span id="localVersion" class="font-semibold text-slate-100">-</span></div>
      <div class="text-sm text-slate-300">Version servidor: <span id="serverVersion" class="font-semibold text-slate-100">-</span></div>
      <div class="text-xs text-slate-400">Publicado: <span id="releasedAt">-</span></div>
      <div id="versionStatus" class="text-sm font-medium text-amber-300">Verificando...</div>
    </section>

    <section class="rounded-2xl border border-slate-800 bg-slate-900 p-4 space-y-3">
      <h2 class="text-sm font-semibold text-slate-200">Actualizacion</h2>
      <button id="btnCheckUpdate" class="w-full px-4 py-3 rounded-xl border border-slate-700 text-slate-100">Buscar actualizacion</button>
      <button id="btnApplyUpdate" class="w-full px-4 py-3 rounded-xl bg-emerald-400 text-slate-950 font-semibold hidden">Aplicar actualizacion disponible</button>
      <button id="btnForceRefresh" class="w-full px-4 py-3 rounded-xl border border-amber-500/40 text-amber-200">Forzar actualizacion completa</button>
      <p class="text-xs text-slate-400">Forzar actualizacion limpia cache local del navegador y recarga la app.</p>
    </section>
  </main>

  <nav id="appShellBottom"></nav>

  <script type="module">
    import { requireAuth } from "/js/auth.js";
    import { initAppShell } from "/js/app-shell.js";
    import { registerServiceWorker, applyUpdate, requestSwVersion } from "/js/sw-register.js";
    import { showToast } from "/js/toast.js";

    const session = await requireAuth();
    if (!session) throw new Error("Redirect login");

    initAppShell({
      title: "About",
      onRefresh: async () => loadVersionInfo()
    });

    const localVersionEl = document.getElementById("localVersion");
    const serverVersionEl = document.getElementById("serverVersion");
    const releasedAtEl = document.getElementById("releasedAt");
    const versionStatusEl = document.getElementById("versionStatus");
    const btnCheckUpdate = document.getElementById("btnCheckUpdate");
    const btnApplyUpdate = document.getElementById("btnApplyUpdate");
    const btnForceRefresh = document.getElementById("btnForceRefresh");

    let lastReg = null;

    function normalizeVersion(v) {
      return String(v || "").trim();
    }

    function renderStatus(localV, serverV) {
      const local = normalizeVersion(localV);
      const server = normalizeVersion(serverV);

      if (!local || !server) {
        versionStatusEl.textContent = "No se pudo comparar versiones.";
        versionStatusEl.className = "text-sm font-medium text-amber-300";
        return;
      }

      if (local === server) {
        versionStatusEl.textContent = "Aplicacion actualizada.";
        versionStatusEl.className = "text-sm font-medium text-emerald-300";
      } else {
        versionStatusEl.textContent = `Hay una version nueva (${server}).`;
        versionStatusEl.className = "text-sm font-medium text-amber-300";
      }
    }

    async function loadVersionInfo() {
      const localVersion = await requestSwVersion();
      localVersionEl.textContent = localVersion || "sin SW activo";

      try {
        const res = await fetch(`/version.json?t=${Date.now()}`, { cache: "no-store" });
        const json = await res.json();
        serverVersionEl.textContent = json?.version || "desconocida";
        releasedAtEl.textContent = json?.releasedAt || "-";
        renderStatus(localVersion, json?.version);
      } catch (e) {
        console.error("Version fetch error:", e);
        serverVersionEl.textContent = "error";
        releasedAtEl.textContent = "-";
        renderStatus(localVersion, null);
      }
    }

    registerServiceWorker({
      onUpdate: (reg) => {
        lastReg = reg;
        btnApplyUpdate.classList.remove("hidden");
        showToast("Nueva version disponible.", { type: "info", duration: 1800 });
      }
    });

    btnCheckUpdate.addEventListener("click", async () => {
      let reg = await navigator.serviceWorker.getRegistration();
      if (!reg) {
        try {
          reg = await navigator.serviceWorker.register("/sw.js");
        } catch {
          reg = null;
        }
      }
      if (!reg) {
        showToast("Service Worker no disponible.", { type: "warning" });
        return;
      }

      showToast("Buscando actualizacion...", { type: "info", duration: 1000 });
      await reg.update().catch(() => {});
      lastReg = reg;

      if (reg.waiting) {
        btnApplyUpdate.classList.remove("hidden");
        showToast("Actualizacion lista para aplicar.", { type: "success", duration: 1800 });
      } else {
        showToast("No hay actualizacion pendiente.", { type: "info", duration: 1600 });
      }

      await loadVersionInfo();
    });

    btnApplyUpdate.addEventListener("click", async () => {
      const reg = lastReg || await navigator.serviceWorker.getRegistration();
      if (!reg?.waiting) {
        showToast("No hay update pendiente para aplicar.", { type: "warning" });
        return;
      }
      applyUpdate(reg);
    });

    btnForceRefresh.addEventListener("click", async () => {
      showToast("Forzando actualizacion...", { type: "info", duration: 1200 });

      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map((r) => r.unregister()));

      if ("caches" in window) {
        const keys = await caches.keys();
        await Promise.all(keys.map((k) => caches.delete(k)));
      }

      location.reload();
    });

    await loadVersionInfo();
  </script>
</body>
</html>
